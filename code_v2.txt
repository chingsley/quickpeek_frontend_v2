// File: app.json
{
  "expo": {
    "name": "quickpeek",
    "slug": "quickpeek_frontend_v2",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/logo.png",
    "scheme": "quickpeekfrontendv2",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/logo.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/logo.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/logo.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}
================================================================================

// File: expo-env.d.ts
/// <reference types="expo/types" />

// NOTE: This file should not be edited and should be in your git ignore
================================================================================

// File: README.md
# Quickpeek Frontend


## Folder structure
/Users/kingsleyeneja/study_projects/my-app
  s/quickpeek/quickpeek_frontend_v2/
  ├───.gitignore
  ├───app.json
  ├───babel.config.js
  ├───eslint.config.js
  ├───package-lock.json
  ├───package.json
  ├───README.md
  ├───scripts.py
  ├───tsconfig.json
  ├───app/
  │   ├───_layout.tsx
  │   ├───index.tsx
  │   ├───(tabs)/
  │   │   ├───_layout.tsx
  │   │   ├───Home.tsx
  │   │   ├───Questions.tsx
  │   │   └───Settings.tsx
  │   ├───answer/
  │   │   └───index.tsx
  │   └───question-detail/
  │       └───index.tsx
  ├───assets/
  │   ├───fonts/
  │   │   ├───Roboto_Condensed-Bold.ttf
  │   │   ├───Roboto_Condensed-Light.ttf
  │   │   ├───Roboto_Condensed-Medium.ttf
  │   │   ├───Roboto_Condensed-Regular.ttf
  │   │   ├───Roboto-Bold.ttf
  │   │   ├───Roboto-ExtraBold.ttf
  │   │   ├───Roboto-ExtraLight.ttf
  │   │   ├───Roboto-Light.ttf
  │   │   ├───Roboto-Medium.ttf
  │   │   ├───Roboto-Regular.ttf
  │   │   └───SpaceMono-Regular.ttf
  │   ├───icons/
  │   │   ├───home.png
  │   │   ├───person.png
  │   │   └───search.png
  │   └───images/
  │       ├───bg.png
  │       ├───logo.png
  │       └───map.png
  ├───components/
  │   ├───CustomTextInput.tsx
  │   ├───CustomTextInput2.tsx
  │   ├───HistoryItem.tsx
  │   ├───RoundButton.tsx
  │   ├───Searchbar.tsx
  │   └───shared/
  │       ├───BackButton.tsx
  │       └───CustomButton.tsx
  ├───constants/
  │   ├───colors.ts
  │   ├───icons.ts
  │   └───images.ts
  ├───interfaces/
  │   └───interfaces.d.ts
  ├───types/
  │   └───images.d.ts
  └───utils/
      ├───date.ts
      └───index.ts

================================================================================

// File: babel.config.js
module.exports = function(api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: ['react-native-reanimated/plugin'],
  };
};
================================================================================

// File: package.json
{
  "name": "quickpeek_frontend_v2",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "start-clear": "npx expo start --clear",
    "start:tunnel": "npx expo start --clear  --tunnel",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "lint": "expo lint"
  },
  "dependencies": {
    "@expo/ngrok": "^4.1.3",
    "@expo/vector-icons": "^15.0.2",
    "@gorhom/bottom-sheet": "^5.2.6",
    "@react-navigation/bottom-tabs": "^7.3.10",
    "@react-navigation/elements": "^2.3.8",
    "@react-navigation/native": "^7.1.6",
    "expo": "^54.0.5",
    "expo-blur": "~15.0.7",
    "expo-constants": "~18.0.9",
    "expo-document-picker": "~14.0.7",
    "expo-font": "~14.0.8",
    "expo-haptics": "~15.0.7",
    "expo-image": "~3.0.8",
    "expo-image-picker": "~17.0.8",
    "expo-linking": "~8.0.8",
    "expo-router": "~6.0.3",
    "expo-splash-screen": "~31.0.10",
    "expo-status-bar": "~3.0.8",
    "expo-symbols": "~1.0.7",
    "expo-system-ui": "~6.0.7",
    "expo-web-browser": "~15.0.7",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.4",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-maps": "1.20.1",
    "react-native-reanimated": "~4.1.0",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-web": "^0.21.0",
    "react-native-webview": "13.15.0",
    "react-native-worklets-core": "^1.6.2",
    "expo-location": "~19.0.7",
    "expo-task-manager": "~14.0.7",
    "expo-notifications": "~0.32.11"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "^19.1.13",
    "eslint": "^9.25.0",
    "eslint-config-expo": "~10.0.0",
    "typescript": "~5.9.2"
  },
  "private": true
}

================================================================================

// File: tsconfig.json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}

================================================================================

// File: eslint.config.js
// https://docs.expo.dev/guides/using-eslint/
const { defineConfig } = require('eslint/config');
const expoConfig = require('eslint-config-expo/flat');

module.exports = defineConfig([
  expoConfig,
  {
    ignores: ['dist/*'],
  },
]);

================================================================================

// File: types/images.d.ts
declare module "*.png" {
  const content: any;
  export default content;
}

================================================================================

// File: context/AuthContext.tsx

import React, { createContext, useState, useContext, ReactNode } from 'react';
import { requestLocationPermissions, startLocationUpdates, stopLocationUpdates } from './../services/location';

interface AuthContextType {
  isAuthenticated: boolean;
  isLocationActive: boolean;
  login: (locationSharingEnabled: boolean) => void;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isLocationActive, setIsLocationActive] = useState(false);

  const login = async (locationSharingEnabled: boolean) => {
    setIsAuthenticated(true);
    if (locationSharingEnabled) {
      const hasPermissions = await requestLocationPermissions();
      if (hasPermissions) {
        await startLocationUpdates();
        setIsLocationActive(true);
      }
    }
  };

  const logout = async () => {
    setIsAuthenticated(false);
    if (isLocationActive) {
      await stopLocationUpdates();
      setIsLocationActive(false);
    }
  };

  return (
    <AuthContext.Provider value={{ isAuthenticated, isLocationActive, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

================================================================================

// File: app/index.tsx

import { useAuth } from './../context/AuthContext';
import { Redirect } from 'expo-router';

const Index = () => {
  const { isAuthenticated } = useAuth();

  if (isAuthenticated) {
    return <Redirect href="/(tabs)/Home" />;
  }

  return <Redirect href="/(auth)/signin" />;
};

export default Index;
================================================================================

// File: app/_layout.tsx
import 'react-native-gesture-handler';
import 'react-native-reanimated';


import { useFonts } from "expo-font";
import { Stack } from "expo-router";
import { GestureHandlerRootView } from "react-native-gesture-handler";
import { BottomSheetModalProvider } from '@gorhom/bottom-sheet';
import { AuthProvider } from './../context/AuthContext';
import { Slot } from 'expo-router';

export default function RootLayout() {
  useFonts({
    'roboto': require('./../assets/fonts/Roboto-Regular.ttf'),
    'roboto-bold': require('./../assets/fonts/Roboto-Bold.ttf'),
    'roboto-light': require('./../assets/fonts/Roboto-Light.ttf'),
    'roboto-extralight': require('./../assets/fonts/Roboto-ExtraLight.ttf'),
    'roboto-medium': require('./../assets/fonts/Roboto-Medium.ttf'),
    'roboto-extrabold': require('./../assets/fonts/Roboto-ExtraBold.ttf'),
    'roboto-condensed-regular': require('./../assets/fonts/Roboto_Condensed-Regular.ttf'),
    'roboto-condensed-bold': require('./../assets/fonts/Roboto_Condensed-Bold.ttf'),
    'roboto-condensed-light': require('./../assets/fonts/Roboto_Condensed-Light.ttf'),
    'roboto-condensed-medium': require('./../assets/fonts/Roboto_Condensed-Medium.ttf'),
    'space-mono-regular': require('./../assets/fonts/SpaceMono-Regular.ttf'),
  });

  return (
    <AuthProvider>
      <GestureHandlerRootView style={{ flex: 1 }}>
        <BottomSheetModalProvider>
          <Slot />
        </BottomSheetModalProvider>
      </GestureHandlerRootView>
    </AuthProvider>
  );
}

================================================================================

// File: app/question-detail/index.tsx
import BackButton from '@/components/shared/BackButton';
import CustomButton from '@/components/shared/CustomButton';
import { colors } from '@/constants/colors';
import { formatDate } from '@/utils/date';
import { useLocalSearchParams } from 'expo-router';
import React from 'react';
import { SafeAreaView, StyleSheet, Text, View } from 'react-native';

const QuestionDetail = () => {
  const { address, question, createdAt, answer, answerRating, responderUsername, isOutbox, isPending } = useLocalSearchParams();

  const handleReask = () => {
    console.log('Re-asking question:', question);
  };

  const isPendingBool = isPending === 'true';

  return (
    <SafeAreaView style={styles.safeAreaContainer}>
      <View style={styles.pageContentContainer}>
        <View style={styles.pageHeader}>
          <BackButton color={colors.PRIMARY} />
        </View>
        <View style={styles.pageBody}>
          <Text style={styles.pageTitle2}>Question Details</Text>
          <View style={styles.contentBox}>
            <View style={styles.questionDetails}>
              <Text style={styles.label}>Time:</Text>
              <Text style={styles.value}>{formatDate(createdAt as string)}</Text>
              <Text style={styles.label}>Location:</Text>
              <Text style={styles.value}>{address}</Text>
              <Text style={styles.label}>Question:</Text>
              <Text style={styles.value}>{question}</Text>
              <Text style={styles.label}>Answer:</Text>
              <Text style={styles.value}>{answer}</Text>
              <Text style={styles.label}>Answer Rating:</Text>
              <Text style={styles.value}>{answerRating}</Text>
              <Text style={styles.label}>Responder:</Text>
              <Text style={styles.value}>{responderUsername}</Text>
            </View>
            {isOutbox === 'true' && (
              <CustomButton
                text={isPendingBool ? 'pending' : 'Re-ask'}
                onPress={handleReask}
                style={styles.btnSubmit}
                disabled={isPendingBool}
              />
            )}
          </View>
        </View>
      </View>
    </SafeAreaView>
  );
};

export default QuestionDetail;

const styles = StyleSheet.create({
  safeAreaContainer: {
    flex: 1,
    backgroundColor: colors.BG_WHITE,
  },
  pageContentContainer: {
    paddingVertical: 20,
    paddingHorizontal: 26,
  },
  pageHeader: {},
  pageBody: {
    marginTop: 40,
  },
  pageTitle2: {
    fontFamily: 'roboto-bold',
    fontSize: 28,
  },
  contentBox: {
    height: '90%',
    marginTop: 20,
  },
  questionDetails: {
    marginBottom: 20,
  },
  label: {
    fontFamily: 'roboto-medium',
    fontSize: 16,
    color: colors.DARK_GRAY,
    marginBottom: 5,
  },
  value: {
    fontFamily: 'roboto',
    fontSize: 18,
    marginBottom: 15,
  },
  btnSubmit: {
    marginTop: 20,
  },
});

================================================================================

// File: app/answer/index.tsx
import CustomTextInput2 from '@/components/CustomTextInput2';
import BackButton from '@/components/shared/BackButton';
import CustomButton from '@/components/shared/CustomButton';
import { colors } from '@/constants/colors';
import { formatDate } from '@/utils/date';
import MaterialCommunityIcons from '@expo/vector-icons/MaterialCommunityIcons';
import * as ImagePicker from 'expo-image-picker';
import { useLocalSearchParams } from 'expo-router';
import React, { useState } from 'react';
import { SafeAreaView, StyleSheet, Text, TouchableOpacity, View } from 'react-native';

const AnswerQuestion = () => {
  const { address, question, createdAt } = useLocalSearchParams();
  const [answer, setAnswer] = useState('');
  const [attachment, setAttachment] = useState<ImagePicker.ImagePickerAsset | null>(null);

  const handleSend = () => {
    console.log('Answer:', answer);
    console.log('Attachment:', attachment);
    // Here you would typically send the answer and attachment to your backend
  };

  const handleAttachment = async () => {
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [4, 3],
        quality: 1,
      });

      if (!result.canceled) {
        setAttachment(result.assets[0]);
      }
    } catch (err) {
      console.log('Error picking image:', err);
    }
  };

  const getTruncatedFilename = (uri: string) => {
    const filename = uri.split('/').pop() || '';
    if (filename.length > 10) {
      return `${filename.substring(0, 10)}...`;
    }
    return filename;
  };

  return (
    <SafeAreaView style={styles.safeAreaContainer}>
      <View style={styles.pageContentContainer}>
        <View style={styles.pageHeader}>
          <BackButton color={colors.PRIMARY} />
        </View>
        <View style={styles.pageBody}>
          <Text style={styles.pageTitle2}>Respond to this question</Text>
          <View style={styles.contentBox}>
            <View style={styles.questionDetails}>
              <Text style={styles.label}>Time:</Text>
              <Text style={styles.value}>{formatDate(createdAt as string)}</Text>
              <Text style={styles.label}>Location:</Text>
              <Text style={styles.value}>{address}</Text>
              <Text style={styles.label}>Question:</Text>
              <Text style={styles.value}>{question}</Text>
            </View>
            <View style={styles.answerArea}>
              <View style={styles.inputContainer}>
                <CustomTextInput2
                  placeholder='Enter your Response'
                  value={answer}
                  handleTextChange={setAnswer}
                />
                <TouchableOpacity onPress={handleAttachment}>
                  <MaterialCommunityIcons name="attachment" size={24} color="black" />
                </TouchableOpacity>
              </View>
              {attachment && <Text>Selected file: {getTruncatedFilename(attachment.uri)}</Text>}
              <CustomButton
                text='Send'
                onPress={handleSend}
                style={styles.btnSubmit}
              />
            </View>
          </View>
        </View>
      </View>
    </SafeAreaView>
  );
};

export default AnswerQuestion;

const styles = StyleSheet.create({
  safeAreaContainer: {
    flex: 1,
    backgroundColor: colors.BG_WHITE,
  },
  pageContentContainer: {
    paddingVertical: 20,
    paddingHorizontal: 26,
  },
  pageHeader: {},
  pageBody: {
    marginTop: 40,
  },
  pageTitle2: {
    fontFamily: 'roboto-bold',
    fontSize: 28,
  },
  contentBox: {
    height: '90%',
    marginTop: 20,
  },
  questionDetails: {
    marginBottom: 20,
  },
  label: {
    fontFamily: 'roboto-medium',
    fontSize: 16,
    color: colors.DARK_GRAY,
    marginBottom: 5,
  },
  value: {
    fontFamily: 'roboto',
    fontSize: 18,
    marginBottom: 15,
  },
  answerArea: {
    marginTop: 20,
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderBottomWidth: 1,
    borderBottomColor: colors.DARK_GRAY,
    paddingBottom: 10,
  },
  btnSubmit: {
    marginTop: 20,
  }
});

================================================================================

// File: app/(tabs)/Settings.tsx
import { useRouter } from 'expo-router';
import React from 'react';
import { StyleSheet, Text, TouchableOpacity, View } from 'react-native';

const Settings = () => {
  const router = useRouter();
  return (
    <View style={styles.container}>
      <Text>Settings</Text>
      <TouchableOpacity
        style={styles.newAskBtn}
        onPress={() => router.push('/')}
      >
        <Text>Answer Question</Text>
      </TouchableOpacity>
    </View>
  );
};

export default Settings;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center"
  },
  newAskBtn: {
    marginVertical: 20,
    borderWidth: 1,
    padding: 20,
    borderRadius: 8,
  }
});
================================================================================

// File: app/(tabs)/Home.tsx
import CustomButton from '@/components/shared/CustomButton';
import { colors } from '@/constants/colors';
import { fonts } from '@/constants/fonts';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import BottomSheet, { BottomSheetView } from '@gorhom/bottom-sheet';
import { useLocalSearchParams, useRouter } from 'expo-router';
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import {
  ActivityIndicator,
  FlatList,
  Keyboard,
  KeyboardAvoidingView,
  Platform,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View
} from 'react-native';
import MapView, { Marker } from 'react-native-maps';


const HomeScreen = () => {
  const bottomSheetRef = useRef<BottomSheet>(null);
  const [question, setQuestion] = useState('Is there a long queue at the bank?');
  const [isFocused, setIsFocused] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [location, setLocation] = useState('');
  const [region, setRegion] = useState({
    latitude: 37.78825,
    longitude: -122.4324,
    latitudeDelta: 0.0922,
    longitudeDelta: 0.0421,
  });
  const [selectedLocation, setSelectedLocation] = useState({
    addressName: '',
    coordinates: {
      latitude: 37.78825,
      longitude: -122.4324,
      latitudeDelta: 0.0922,
      longitudeDelta: 0.0421,
    }
  });
  const [suggestions, setSuggestions] = useState<any[]>([]);
  const [addressSelected, setAddressSelected] = useState(false);
  const [mode, setMode] = useState<'edit' | 'preview'>('edit');

  const snapPoints = useMemo(() => ['20%', '50%', '90%'], []);
  const params = useLocalSearchParams();
  const router = useRouter();

  useEffect(() => {
    const { question: questionParam, address: addressParam, location: locationParam } = params;

    if (questionParam && addressParam && locationParam && typeof locationParam === 'string') {
      const [latitude, longitude] = locationParam.split(',').map(parseFloat);

      setQuestion(questionParam as string);
      setLocation(addressParam as string);
      setSelectedLocation({
        addressName: addressParam as string,
        coordinates: {
          latitude,
          longitude,
          latitudeDelta: 0.0922,
          longitudeDelta: 0.0421,
        },
      });
      setRegion({
        latitude,
        longitude,
        latitudeDelta: 0.0922,
        longitudeDelta: 0.0421,
      });
      setMode('preview');
      setAddressSelected(true);
      bottomSheetRef.current?.snapToIndex(1);
      router.setParams({ question: '', address: '', location: '' });
    }
  }, [params]);

  const handleSheetChanges = useCallback((index: number) => {
    if (index === 0) {
      setIsFocused(false);
      Keyboard.dismiss();
    }
  }, []);

  const handleFocus = () => {
    bottomSheetRef.current?.snapToIndex(3);
    setIsFocused(true);
  };

  const handleBlur = () => {
    setIsFocused(false);
  };

  const handleDone = () => {
    console.log({ location, question }, 'testing');
    setMode('preview');
    Keyboard.dismiss();
    bottomSheetRef.current?.snapToIndex(1);
    setLocation(selectedLocation.addressName);
    setRegion(selectedLocation.coordinates);
  };

  const handlePost = () => {
    console.log({ location, question });
    // // Reset form after posting
    // setLocation('');
    // setQuestion('');
    // setMode('edit');
    // bottomSheetRef.current?.snapToIndex(0);
  };

  const handleEdit = () => {
    setMode('edit');
    bottomSheetRef.current?.snapToIndex(3);
  };

  const handleLocationChange = async (text: string) => {
    if (addressSelected) setAddressSelected(false);
    setSelectedLocation(prev => ({
      ...prev,
      addressName: text,
    }));
    setAddressSelected(false);
    if (text.length > 2) {
      setIsLoading(true);
      try {
        const response = await fetch(
          `https://nominatim.openstreetmap.org/search?q=${text}&format=json&limit=5`
        );
        const data = await response.json();
        setSuggestions(data);
      } catch (error) {
        console.error('Error fetching location suggestions:', error);
      } finally {
        setIsLoading(false);
      }
    } else {
      setSuggestions([]);
    }
  };

  const onSuggestionPress = (item: any) => {
    try {
      setSelectedLocation({
        addressName: item.display_name,
        coordinates: {
          latitude: parseFloat(item.lat),
          longitude: parseFloat(item.lon),
          latitudeDelta: 0.0922,
          longitudeDelta: 0.0421,
        }
      });
      setLocation(item.display_name);
      setSuggestions([]);
      setAddressSelected(true);
    } catch (error) {
      console.log('onSuggestionPress error', error);
    }
  };

  const renderSuggestionItem = ({ item }: { item: any; }) => (
    <TouchableOpacity
      style={styles.suggestionItem}
      onPress={() => onSuggestionPress(item)}
    >
      <Text style={styles.suggestionText}>{item.display_name}</Text>
    </TouchableOpacity>
  );
  console.log('>>>>>', { region }, '\n******', { location });
  return (
    <View style={styles.container}>
      <MapView style={styles.map} region={region}>
        <Marker coordinate={region} />
      </MapView>

      <BottomSheet
        ref={bottomSheetRef}
        index={0}
        snapPoints={snapPoints}
        onChange={handleSheetChanges}
        backgroundStyle={styles.bottomSheetBackground}
        handleIndicatorStyle={styles.handleIndicator}
        enablePanDownToClose={false}
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={styles.keyboardAvoidingView}
        >
          <BottomSheetView style={styles.contentContainer}>
            {mode === 'edit' ? (
              <>
                <Text style={styles.inputLabel}>Choose a location for your question</Text>
                <View style={styles.searchContainer}>
                  <TextInput
                    style={styles.searchInput}
                    placeholder="Choose a location for your question"
                    placeholderTextColor={colors.MEDIUM_GRAY}
                    value={selectedLocation.addressName}
                    onChangeText={handleLocationChange}
                    onFocus={handleFocus}
                    onBlur={handleBlur}
                  />
                  {isLoading && <ActivityIndicator size="small" color={colors.PRIMARY} style={styles.loader} />}
                </View>
                <View style={styles.suggestionsContainerParent}>
                  {suggestions.length > 0 && (
                    <View style={styles.suggestionsContainer}>
                      <FlatList
                        data={suggestions}
                        keyExtractor={(item) => String(item.place_id)}
                        renderItem={renderSuggestionItem}
                        keyboardShouldPersistTaps="handled"
                      />
                    </View>
                  )}
                </View>
                <View style={styles.questNButtonContainer}>
                  <Text style={styles.inputLabel}>What do you want to know about this location?</Text>
                  <TextInput
                    style={styles.questionInput}
                    placeholder="Enter your question"
                    placeholderTextColor={colors.MEDIUM_GRAY}
                    value={question}
                    onChangeText={setQuestion}
                    multiline
                    onFocus={handleFocus}
                  />
                  <CustomButton
                    text="Done"
                    onPress={handleDone}
                    style={styles.postButton}
                    disabled={!addressSelected || !question}
                  />
                </View>
              </>
            ) : (
              <>
                <View style={styles.previewHeader}>
                  <Text style={styles.previewTitle}>Preview</Text>
                </View>

                <View style={styles.previewSection}>
                  <View style={styles.previewRow}>
                    <Text style={styles.previewValue}>{location}</Text>
                    <TouchableOpacity onPress={handleEdit} style={styles.editButton}>
                      <FontAwesome name="pencil" size={16} color={colors.PRIMARY} />
                    </TouchableOpacity>
                  </View>
                </View>

                <View style={styles.previewSection}>
                  <View style={styles.previewRow}>
                    <Text style={styles.previewValue}>{question}</Text>
                    <TouchableOpacity onPress={handleEdit} style={styles.editButton}>
                      <FontAwesome name="pencil" size={16} color={colors.PRIMARY} />
                    </TouchableOpacity>
                  </View>
                </View>

                <CustomButton
                  text="Post Question"
                  onPress={handlePost}
                  style={styles.postButton}
                />
              </>
            )}
          </BottomSheetView>
        </KeyboardAvoidingView>
      </BottomSheet>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  map: {
    ...StyleSheet.absoluteFillObject,
  },
  keyboardAvoidingView: {
    flex: 1,
  },
  contentContainer: {
    flex: 1,
    padding: 20,
    paddingBottom: 30,
  },
  inputLabel: {
    fontFamily: 'roboto-bold',
    fontSize: 18,
    marginBottom: 10,
    color: colors.DARK_GRAY,
  },
  bottomSheetBackground: {
    backgroundColor: colors.BG_WHITE,
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
  },
  handleIndicator: {
    backgroundColor: colors.LIGHT_GRAY,
    width: 40,
    height: 4,
  },
  searchContainer: {
    position: 'relative',
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  searchInput: {
    flex: 1,
    borderWidth: 2,
    borderColor: colors.LIGHT_GRAY_THIN,
    borderRadius: 8,
    padding: 10,
    fontSize: 18,
    fontFamily: 'roboto',
    color: colors.DARK_GRAY,
    backgroundColor: colors.BG_WHITE,
    height: 50,
  },
  loader: {
    position: 'absolute',
    right: 12,
  },
  suggestionsContainerParent: {
    position: 'relative',
  },
  suggestionsContainer: {
    height: 550,
    marginBottom: 12,
    backgroundColor: colors.BG_WHITE,
    elevation: 3,
    position: 'absolute',
    top: 1,
    zIndex: 100,
    width: '100%',
  },
  suggestionItem: {
    paddingVertical: 16,
    paddingHorizontal: 8,
    borderBottomWidth: 1,
    borderBottomColor: colors.LIGHT_GRAY_THIN,
  },
  suggestionText: {
    fontSize: fonts.FONT_SIZE_SMALL,
    color: colors.DARK_GRAY,
  },
  questNButtonContainer: {
    marginTop: 20,
  },
  questionInput: {
    borderWidth: 1,
    borderColor: colors.LIGHT_GRAY,
    borderRadius: 10,
    padding: 12,
    fontSize: fonts.FONT_SIZE_MEDIUM,
    color: colors.DARK_GRAY,
    backgroundColor: colors.BG_WHITE,
    minHeight: 100,
    textAlignVertical: 'top',
  },
  postButton: {
    marginTop: 0,
  },
  previewHeader: {
    marginBottom: 20,
  },
  previewTitle: {
    fontFamily: 'roboto-bold',
    fontSize: 24,
    color: colors.DARK_GRAY,
  },
  previewSection: {
    marginBottom: 5,
  },
  previewRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: colors.LIGHT_GRAY_THIN,
    borderRadius: 8,
    padding: 10,
    marginBottom: 12,
    backgroundColor: colors.BG_WHITE,
  },
  previewValue: {
    flex: 1,
    lineHeight: 22,
    fontSize: fonts.FONT_SIZE_MEDIUM,
    fontFamily: 'roboto',
    color: colors.DARK_GRAY,
    maxWidth: '90%',
  },
  editButton: {
    padding: 8,
  },
});

export default HomeScreen;
================================================================================

// File: app/(tabs)/Questions.tsx
import questions from '@/_playground/questions.json';
import HistoryItem from '@/components/HistoryItem';
import { colors } from '@/constants/colors';
import { fonts } from '@/constants/fonts';
import FontAwesome6 from '@expo/vector-icons/FontAwesome6';
import Ionicons from '@expo/vector-icons/Ionicons';
import { useRouter } from 'expo-router';
import React, { useState } from 'react';
import { FlatList, Pressable, SafeAreaView, StyleSheet, Text, TouchableOpacity, View } from 'react-native';

const Questions = () => {
  const [activeTab, setActiveTab] = useState('Inbox');
  const router = useRouter();

  const openModal = () => { };

  const newQuestions = questions.slice(0, 3);
  const pastQuestions = questions.slice(3).sort((a, b) => {
    if (a.isPending && !b.isPending) {
      return -1;
    }
    if (!a.isPending && b.isPending) {
      return 1;
    }
    return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
  });
  const newQuestionsCount = newQuestions.filter(q => q.isNew).length;

  const handleHistoryItemClick = (item: (typeof questions)[0]) => {
    if (activeTab === 'Inbox') {
      if (item.isNew) {
        router.push({
          pathname: '/answer',
          params: {
            address: item.address,
            question: item.content,
            createdAt: item.createdAt,
          },
        });
      } else {
        router.push({
          pathname: '/question-detail',
          params: {
            address: item.address,
            question: item.content,
            createdAt: item.createdAt,
            answer: item.answer,
            answerRating: item.answerRating,
            responderUsername: item.responderUsername,
          },
        });
      }
    } else { // An outbox history item is clicked
      router.push({
        pathname: '/question-detail',
        params: {
          address: item.address,
          question: item.content,
          createdAt: item.createdAt,
          answer: item.answer,
          answerRating: item.answerRating,
          responderUsername: item.responderUsername,
          isOutbox: 'true',
          isPending: item.isPending ? 'true' : 'false',
        },
      });
    }
  };

  return (
    <SafeAreaView style={styles.safeAreaContainer}>
      <View style={styles.pageContentContainer}>
        <View style={styles.titleSection}>
          <Text style={styles.pageTitle}>Questions</Text>
          <Pressable onPress={openModal}>
            <Ionicons name="information-circle-outline" size={28} color={colors.DARK_GRAY} />
          </Pressable>
        </View>
        <View style={styles.tabContainer}>
          <View style={styles.tabHeader}>
            <TouchableOpacity onPress={() => setActiveTab('Inbox')} style={[styles.tab, activeTab === 'Inbox' && styles.activeTab]}>
              <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                <Text style={[styles.tabText, activeTab === 'Inbox' && styles.activeTabText]}>Inbox</Text>
                {newQuestionsCount > 0 && (
                  <View style={styles.newBadge}>
                    <Text style={styles.newBadgeText}>{newQuestionsCount}</Text>
                  </View>
                )}
              </View>
            </TouchableOpacity>
            <TouchableOpacity onPress={() => setActiveTab('Outbox')} style={[styles.tab, activeTab === 'Outbox' && styles.activeTab]}>
              <Text style={[styles.tabText, activeTab === 'Outbox' && styles.activeTabText]}>Outbox</Text>
            </TouchableOpacity>
          </View>
          <FlatList
            data={activeTab === 'Inbox' ? newQuestions : pastQuestions}
            renderItem={({ item }) => (
              <View style={styles.qnItemContainer}>
                <HistoryItem
                  onClick={() => handleHistoryItemClick(item)}
                  question={item.content}
                  address={item.address}
                  createdAt={item.createdAt}
                />
                {item.isNew && activeTab === 'Inbox' && <Text style={styles.newTag}>new</Text>}
                {item.isPending && activeTab === 'Outbox' && <Text style={styles.pendingTag}>pending</Text>}
                {activeTab === 'Outbox' &&
                  <Pressable
                    style={styles.arrowRotateIconBtn}
                    onPress={() =>
                      router.push({
                        pathname: '/(tabs)/Home',
                        params: {
                          question: item.content,
                          address: item.address,
                          location: item.location,
                        },
                      })
                    }
                  >
                    <View style={styles.arrowRotateIconBG}>
                      <FontAwesome6 name="arrow-rotate-left" size={16} color={colors.DARK_GRAY} />
                    </View>
                  </Pressable>
                }
              </View>
            )}
            ItemSeparatorComponent={() => <View style={styles.separator} />}
            contentContainerStyle={{ paddingTop: 20 }}
          />
        </View>
      </View>
    </SafeAreaView>
  );
};

export default Questions;

const styles = StyleSheet.create({
  safeAreaContainer: {
    height: '100%',
    backgroundColor: colors.BG_WHITE
  },
  pageContentContainer: {
    paddingVertical: 20,
    paddingHorizontal: 26,
  },
  titleSection: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between'
  },
  pageTitle: {
    fontFamily: 'roboto-bold',
    fontSize: 28,
  },
  tabContainer: {
    marginTop: 25,
  },
  tabHeader: {
    flexDirection: 'row',
    borderBottomWidth: 1.5,
    borderBottomColor: colors.LIGHT_GRAY,
  },
  tab: {
    paddingVertical: 10,
    marginRight: 20,
  },
  activeTab: {
    borderBottomWidth: 2,
    borderBottomColor: colors.PRIMARY,
  },
  tabText: {
    fontFamily: 'roboto-medium',
    fontSize: 20,
    color: colors.DARK_GRAY,
  },
  activeTabText: {

  },
  separator: {
    height: 1,
    backgroundColor: colors.LIGHT_GRAY,
    marginVertical: 20,
  },
  qnItemContainer: {
    display: 'flex',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center'
  },
  arrowRotateIconBtn: {
    padding: 10,
  },
  arrowRotateIconBG: {
    padding: 8,
    borderRadius: '50%',
    backgroundColor: colors.LIGHT_GRAY_THIN,

  },
  newBadge: {
    backgroundColor: colors.RED,
    borderRadius: 10,
    width: 20,
    height: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 5,
  },
  newBadgeText: {
    color: colors.BG_WHITE,
    fontSize: fonts.FONT_SIZE_SMALL,
    fontWeight: 'bold',
  },
  newTag: {
    color: colors.RED,
    fontSize: 16,
    fontFamily: 'roboto-bold',
  },
  pendingTag: {
    color: colors.PRIMARY,
    fontSize: 16,
    fontFamily: 'roboto-bold',
  },
});
================================================================================

// File: app/(tabs)/_layout.tsx
import { colors } from '@/constants/colors';
import FontAwesome6 from '@expo/vector-icons/FontAwesome6';
import Ionicons from '@expo/vector-icons/Ionicons';
import { Tabs } from 'expo-router';
import React from 'react';

const _layout = () => {
  return (
    <Tabs
      screenOptions={{
        tabBarShowLabel: true,
        tabBarLabelStyle: {
          fontSize: 12,
          marginTop: 2,
          color: colors.PRIMARY,
        },
        tabBarItemStyle: {
          // borderWidth: 1,
        },
        tabBarStyle: {
          // borderWidth: 1,
          // borderColor: 'red',
          height: 100,
          backgroundColor: colors.DARK_WHITE
        }
      }}
    >
      <Tabs.Screen
        name="Home"
        options={{
          title: 'Home',
          headerShown: false, // comment this out to show 'Home' as title of this page. Note if Tabs.Screen is not provided for the rest of the routes (Question, Settings, etc), they will show by default
          tabBarIcon: ({ focused, size }) => <Ionicons name="home-outline" size={size} color={focused ? colors.ACTIVE : colors.PRIMARY} />
        }}
      />
      <Tabs.Screen
        name="Questions"
        options={{
          title: 'Questions',
          headerShown: false, // comment this out to show 'Home' as title of this page. Note if Tabs.Screen is not provided for the rest of the routes (Questions, Settings, etc), they will show by default
          tabBarIcon: ({ focused, size }) => <FontAwesome6 name="person-circle-question" size={size} color={focused ? colors.ACTIVE : colors.PRIMARY} />,
          tabBarLabel: 'Questions'
        }}
      />
      <Tabs.Screen
        name="Settings"
        options={{
          title: 'Settings',
          // headerShown: false, // comment this out to show 'Home' as title of this page. Note if Tabs.Screen is not provided for the rest of the routes (Question, Settings, etc), they will show by default
          tabBarIcon: ({ focused, size }) => <Ionicons name="settings-outline" size={size} color={focused ? colors.ACTIVE : colors.PRIMARY} />,
          tabBarLabel: 'Settings'
        }}
      />
    </Tabs>
  );
};

export default _layout;


================================================================================

// File: app/(auth)/signup.tsx

import { View, Text, StyleSheet, TextInput, TouchableOpacity, Alert, Switch, KeyboardAvoidingView, ScrollView, Platform } from 'react-native';
import React, { useState } from 'react';
import { useRouter } from 'expo-router';
import { useAuth } from '../../context/AuthContext';
import * as Notifications from 'expo-notifications';
import Constants from 'expo-constants';

// Define the shape of the form data
interface FormData {
  name: string;
  username: string;
  email: string;
  password: string;
  confirmPassword: string;
  locationSharingEnabled: boolean;
  notificationsEnabled: boolean;
  deviceToken: string;
  deviceType: string | undefined;
}

// Props for the step components
interface Step1Props {
  formData: FormData;
  setFormData: React.Dispatch<React.SetStateAction<FormData>>;
  nextStep: () => void;
}

interface Step2Props {
  formData: FormData;
  setFormData: React.Dispatch<React.SetStateAction<FormData>>;
  nextStep: () => void;
  prevStep: () => void;
}

interface Step3Props {
  formData: FormData;
  prevStep: () => void;
  handleSignup: () => void;
}

async function registerForPushNotificationsAsync() {
  let token;
  if (Constants.isDevice) {
    const { status: existingStatus } = await Notifications.getPermissionsAsync();
    let finalStatus = existingStatus;
    if (existingStatus !== 'granted') {
      const { status } = await Notifications.requestPermissionsAsync();
      finalStatus = status;
    }
    if (finalStatus !== 'granted') {
      alert('Failed to get push token for push notification!');
      return;
    }
    token = (await Notifications.getExpoPushTokenAsync({ projectId: 'quickpeek_frontend_v2' })).data;
    console.log(token);
  } else {
    alert('Must use physical device for Push Notifications');
  }

  return token;
}

const Step1: React.FC<Step1Props> = ({ formData, setFormData, nextStep }) => {
  return (
    <View style={styles.stepContainer}>
      <View style={styles.inputContainer}>
        <Text style={styles.label}>Name</Text>
        <TextInput
          style={styles.input}
          placeholder="Name"
          value={formData.name}
          onChangeText={(text) => setFormData({ ...formData, name: text })}
        />
      </View>
      <View style={styles.inputContainer}>
        <Text style={styles.label}>Username</Text>
        <TextInput
          style={styles.input}
          placeholder="Username"
          value={formData.username}
          onChangeText={(text) => setFormData({ ...formData, username: text })}
        />
      </View>
      <View style={styles.inputContainer}>
        <Text style={styles.label}>Email</Text>
        <TextInput
          style={styles.input}
          placeholder="Email"
          value={formData.email}
          onChangeText={(text) => setFormData({ ...formData, email: text })}
          keyboardType="email-address"
          autoCapitalize="none"
        />
      </View>
      <View style={styles.inputContainer}>
        <Text style={styles.label}>Password</Text>
        <TextInput
          style={styles.input}
          placeholder="Password"
          value={formData.password}
          onChangeText={(text) => setFormData({ ...formData, password: text })}
          secureTextEntry
        />
      </View>
      <View style={styles.inputContainer}>
        <Text style={styles.label}>Confirm Password</Text>
        <TextInput
          style={styles.input}
          placeholder="Confirm Password"
          value={formData.confirmPassword}
          onChangeText={(text) => setFormData({ ...formData, confirmPassword: text })}
          secureTextEntry
        />
      </View>
      <TouchableOpacity style={styles.button} onPress={nextStep}>
        <Text style={styles.buttonText}>Next</Text>
      </TouchableOpacity>
    </View>
  );
};

const Step2: React.FC<Step2Props> = ({ formData, setFormData, nextStep, prevStep }) => {
  const handleNotificationsToggle = async (value: boolean) => {
    setFormData(prev => ({ ...prev, notificationsEnabled: value }));
    if (value) {
      const token = await registerForPushNotificationsAsync();
      if (token) {
        setFormData(prev => ({ ...prev, deviceToken: token }));
      }
    }
  };

  return (
    <View style={styles.stepContainer}>
      <View style={styles.switchContainer}>
        <Text>Enable Location Sharing</Text>
        <Switch
          value={formData.locationSharingEnabled}
          onValueChange={(value) => setFormData({ ...formData, locationSharingEnabled: value })}
        />
      </View>
      <View style={styles.switchContainer}>
        <Text>Enable Notifications</Text>
        <Switch
          value={formData.notificationsEnabled}
          onValueChange={handleNotificationsToggle}
        />
      </View>
      <TouchableOpacity style={styles.button} onPress={nextStep}>
        <Text style={styles.buttonText}>Next</Text>
      </TouchableOpacity>
      <TouchableOpacity style={styles.button} onPress={prevStep}>
        <Text style={styles.buttonText}>Back</Text>
      </TouchableOpacity>
    </View>
  );
};

const Step3: React.FC<Step3Props> = ({ formData, prevStep, handleSignup }) => {
  return (
    <View style={styles.stepContainer}>
      <Text>Review your details:</Text>
      <Text>Name: {formData.name}</Text>
      <Text>Username: {formData.username}</Text>
      <Text>Email: {formData.email}</Text>
      <TouchableOpacity style={styles.button} onPress={handleSignup}>
        <Text style={styles.buttonText}>Sign Up</Text>
      </TouchableOpacity>
      <TouchableOpacity style={styles.button} onPress={prevStep}>
        <Text style={styles.buttonText}>Back</Text>
      </TouchableOpacity>
    </View>
  );
};

const signup = () => {
  const router = useRouter();
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState<FormData>({
    name: '',
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
    locationSharingEnabled: false,
    notificationsEnabled: false,
    deviceToken: '',
    deviceType: Constants.platform?.ios ? 'ios' : 'android',
  });

  const nextStep = () => setStep(step + 1);
  const prevStep = () => setStep(step - 1);

  const { login } = useAuth();

  const handleSignup = () => {
    // In a real app, you'd send the formData to your backend
    console.log(JSON.stringify(formData, null, 2));
    login(formData.locationSharingEnabled);
  };

  const renderStep = () => {
    switch (step) {
      case 1:
        return <Step1 formData={formData} setFormData={setFormData} nextStep={nextStep} />;
      case 2:
        return <Step2 formData={formData} setFormData={setFormData} nextStep={nextStep} prevStep={prevStep} />;
      case 3:
        return <Step3 formData={formData} prevStep={prevStep} handleSignup={handleSignup} />;
      default:
        return null;
    }
  };

  return (
    <KeyboardAvoidingView
      style={{ flex: 1 }}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView contentContainerStyle={styles.scrollContainer}>
        <View style={styles.container}>
          <Text style={styles.title}>Sign Up - Step {step} of 3</Text>
          {renderStep()}
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

export default signup;

const styles = StyleSheet.create({
  scrollContainer: {
    flexGrow: 1,
    justifyContent: 'center',
  },
  container: {
    alignItems: 'center',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
  },
  inputContainer: {
    width: '100%',
    marginBottom: 10,
  },
  label: {
    alignSelf: 'flex-start',
    marginBottom: 5,
    fontSize: 16,
    fontWeight: '500',
  },
  stepContainer: {
    width: '100%',
  },
  input: {
    width: '100%',
    height: 50,
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 8,
    paddingHorizontal: 10,
    marginBottom: 10,
  },
  button: {
    width: '100%',
    height: 50,
    backgroundColor: 'blue',
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 8,
    marginTop: 10,
  },
  buttonText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
  },
  switchContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    width: '100%',
    marginBottom: 20,
  },
});

================================================================================

// File: app/(auth)/_layout.tsx

import { Stack } from 'expo-router';
import React from 'react';

const AuthLayout = () => {
  return (
    <Stack>
      <Stack.Screen name="signin" options={{ headerShown: false }} />
      <Stack.Screen name="signup" options={{ headerShown: false }} />
    </Stack>
  );
};

export default AuthLayout;

================================================================================

// File: app/(auth)/signin.tsx
import { colors } from '@/constants/colors';
import { useRouter } from 'expo-router';
import React, { useState } from 'react';
import { KeyboardAvoidingView, Platform, ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { useAuth } from '../../context/AuthContext';

const signin = () => {
  const router = useRouter();
  const { login } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSignIn = () => {
    console.log('Email:', email);
    console.log('Password:', password);
    login(false);
    router.push('/');
  };

  return (
    <KeyboardAvoidingView
      style={{ flex: 1 }}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView contentContainerStyle={styles.scrollContainer}>
        <View style={styles.container}>
          <Text style={styles.title}>Sign In</Text>
          <View style={styles.inputContainer}>
            <Text style={styles.label}>Email</Text>
            <TextInput
              style={styles.input}
              placeholder="Email"
              value={email}
              onChangeText={setEmail}
              keyboardType="email-address"
              autoCapitalize="none"
            />
          </View>
          <View style={styles.inputContainer}>
            <Text style={styles.label}>Password</Text>
            <TextInput
              style={styles.input}
              placeholder="Password"
              value={password}
              onChangeText={setPassword}
              secureTextEntry
            />
          </View>
          <TouchableOpacity style={styles.button} onPress={handleSignIn}>
            <Text style={styles.buttonText}>Sign In</Text>
          </TouchableOpacity>
          <TouchableOpacity onPress={() => router.push('/(auth)/signup')}>
            <Text style={styles.link}>Don't have an account? Sign up</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

export default signin;

const styles = StyleSheet.create({
  scrollContainer: {
    flexGrow: 1,
    justifyContent: 'center',
  },
  container: {
    alignItems: 'center',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
  },
  inputContainer: {
    width: '100%',
    marginBottom: 10,
  },
  label: {
    alignSelf: 'flex-start',
    marginBottom: 5,
    fontSize: 16,
    fontWeight: '500',
  },
  input: {
    width: '100%',
    height: 50,
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 8,
    paddingHorizontal: 10,
    marginBottom: 10,
  },
  button: {
    width: '100%',
    height: 50,
    backgroundColor: colors.PRIMARY,
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 8,
    marginTop: 10,
  },
  buttonText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
  },
  link: {
    marginTop: 20,
    color: 'blue',
  },
});
================================================================================

// File: constants/colors.ts
export const colors = {
  PRIMARY: "#1573FE",
  ACTIVE: '#CB2AF7',
  DARK_WHITE: '##F0F0F0',
  BG_WHITE: '#FFFFFF',
  BG_BLACK: '#000000',
  LIGHT_BLUE: '#DFF1FF',
  LIGHT_GREEN: '#E8FFEB',
  LIGHT_PINK: '#FFECEF',
  DARK_GRAY: '#485460',
  LIGHT_GRAY: '#d2dae2',
  LIGHT_GRAY_THIN: '#dddddd80',
  MEDIUM_GRAY: '#888888',
  RED: 'red'
};

================================================================================

// File: constants/fonts.ts
export const fonts = {
  FONT_SIZE_MEDIUM: 18,
  FONT_SIZE_SMALL: 16,
};
================================================================================

// File: constants/images.ts
import bg from "@/assets/images/bg.png";
import map from "@/assets/images/map.png";

export const images = {
  bg,
  map,
};

================================================================================

// File: constants/icons.ts
import search from "@/assets/icons/search.png";

export const icons = {
  search,
};

================================================================================

// File: utils/date.ts
export const formatDate = (dateString: string) => {
  const date = new Date(dateString);
  const day = date.getDate();
  const month = date.toLocaleString('default', { month: 'short' });
  const hours = date.getHours();
  const minutes = date.getMinutes();

  return `${day} ${month} • ${hours}:${minutes.toString().padStart(2, '0')}`;
};
================================================================================

// File: utils/index.ts
export const drawBorder = (color = 'black') => ({
  borderWidth: 0,
  borderColor: color,
});
================================================================================

// File: components/CustomTextInput.tsx
import { drawBorder } from '@/utils';
import React from 'react';
import { StyleSheet, TextInput } from 'react-native';

interface Props {
  value: string;
  placeholder: string;
  handleTextChange: React.Dispatch<React.SetStateAction<string>>;
}

const CustomTextInput = ({ value, placeholder, handleTextChange }: Props) => {
  return (
    <TextInput
      placeholder={placeholder}
      placeholderTextColor='#7a7b80ff'
      value={value}
      onChangeText={(value) => handleTextChange(value)}
      style={styles.textInput}
      multiline={true}
      numberOfLines={4} // Hint for Android, not a strict limit
    />
  );
};

export default CustomTextInput;

const styles = StyleSheet.create({
  textInput: {
    ...drawBorder(),
    color: '#333',
    fontSize: 18,
    backgroundColor: '#F5F5F5',
    borderRadius: 10,
    paddingHorizontal: 10,
    minHeight: 100,
    borderWidth: 1,
  },
});
================================================================================

// File: components/Searchbar.tsx
import { colors } from '@/constants/colors';
import { icons } from '@/constants/icons';
import React from 'react';
import { Image, StyleSheet, TextInput, View } from 'react-native';

interface Props {
  placeholder: string;
  inputValue: string;
  setValue: (value: string) => void;
}

const Searchbar = ({ placeholder, inputValue, setValue }: Props) => {
  // const [value, setValue] = useState(inputValue);
  return (
    <View style={styles.container}>
      <Image style={styles.searchIcon} source={icons.search} resizeMode="contain" tintColor='#333' />
      <TextInput
        placeholder={placeholder}
        placeholderTextColor='#a8b5db'
        value={inputValue}
        onChangeText={(value) => setValue(value)}
        style={styles.input}
      />
    </View>
  );
};

export default Searchbar;

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 0.4,
    borderRadius: 10,
    paddingLeft: 20,
    backgroundColor: colors.BG_WHITE,
    // backgroundColor: '#F5F5F5',
    height: 50
  },
  searchIcon: {
    width: 20,
    height: 20,
  },
  input: {
    flex: 1,
    marginLeft: 8,
    color: '#333',
    height: '100%',
    fontSize: 20,
    paddingRight: 10,
  },
  label: {
    // default Text styling
  },

});
================================================================================

// File: components/HistoryItem.tsx
import { colors } from '@/constants/colors';
import { fonts } from '@/constants/fonts';
import { formatDate } from '@/utils/date';
import Ionicons from '@expo/vector-icons/Ionicons';
import React from 'react';
import { StyleSheet, Text, TouchableOpacity, View } from 'react-native';

interface Props {
  address: string;
  question: string;
  createdAt: string;
  onClick: () => void;
}

const HistoryItem = ({ address, question, createdAt, onClick }: Props) => {
  const handlePress = () => {
    onClick();
  };
  return (
    <TouchableOpacity onPress={handlePress} style={styles.clickableContainer}>
      <Ionicons name="time-outline" size={15} color="black" />
      <View style={styles.textContainer}>
        <Text style={styles.date}>{formatDate(createdAt)}</Text>
        <Text style={styles.address}>{address}</Text>
        <Text style={styles.question}>{question}</Text>
      </View>
    </TouchableOpacity>

  );
};

export default HistoryItem;

const styles = StyleSheet.create({
  clickableContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
  },
  textContainer: {
    maxWidth: 300,
  },
  date: {
    color: colors.MEDIUM_GRAY,
    fontFamily: 'roboto-light',
    fontSize: fonts.FONT_SIZE_SMALL,
    marginBottom: 5,
  },
  address: {
    color: '#333',
    fontFamily: 'roboto',
    fontSize: 20,
    fontStyle: 'normal',
    fontWeight: '400',
    letterSpacing: 0.14,
  },
  question: {
    fontSize: 16,
    fontFamily: 'roboto-light',
  }
});
================================================================================

// File: components/RoundButton.tsx
import { colors } from '@/constants/colors';
import { drawBorder } from '@/utils';
import Ionicons from '@expo/vector-icons/Ionicons';
import React from 'react';
import { StyleSheet, TouchableOpacity, View } from 'react-native';


interface Props {
  onPress: () => void;
}

const RoundButton = ({ onPress }: Props) => {
  return (
    <TouchableOpacity onPress={onPress}>
      <View style={{
        ...drawBorder(colors.PRIMARY),
        borderWidth: 1,
        borderColor: colors.PRIMARY,
        width: 50,
        height: 50,
        justifyContent: 'center',
        alignItems: 'center',
        borderRadius: '50%'

      }}>
        <Ionicons name="arrow-forward" size={24} color={colors.PRIMARY} />
      </View>
    </TouchableOpacity>

  );
};

export default RoundButton;

const styles = StyleSheet.create({});
================================================================================

// File: components/CustomTextInput2.tsx
import { colors } from '@/constants/colors';
import React from 'react';
import { StyleSheet, TextInput } from 'react-native';

interface Props {
  value: string;
  placeholder: string;
  handleTextChange: React.Dispatch<React.SetStateAction<string>>;
}

const CustomTextInput = ({ value, placeholder, handleTextChange }: Props) => {
  return (
    <TextInput
      placeholder={placeholder}
      placeholderTextColor='#7a7b80ff'
      value={value}
      onChangeText={(value) => handleTextChange(value)}
      style={styles.textInput}
    // multiline={true}
    // numberOfLines={1} // Hint for Android, not a strict limit
    />
  );
};

export default CustomTextInput;

const styles = StyleSheet.create({
  textInput: {
    flex: 1,
    color: '#333',
    fontSize: 18,
    // backgroundColor: '#F5F5F5',
    // borderRadius: 10,
    // paddingHorizontal: 10,
    // minHeight: 100,
    paddingBottom: 8,
    marginRight: 10,
  },
});
================================================================================

// File: components/shared/BackButton.tsx
import FontAwesome6 from '@expo/vector-icons/FontAwesome6';
import { useRouter } from 'expo-router';
import React from 'react';
import { Pressable, StyleSheet } from 'react-native';

interface IBackButtonProps {
  color?: string;
  style?: object;
}
const BackButton = ({ color, style }: IBackButtonProps) => {
  const router = useRouter();

  return (
    <Pressable style={style} onPress={() => router.back()}>
      <FontAwesome6 name="arrow-left-long" size={28} color={color || 'black'} />
    </Pressable>
  );
};

export default BackButton;

const styles = StyleSheet.create({
  backArrow: {
    // paddingHorizontal: 10,
    borderWidth: 1,
  }
});
================================================================================

// File: components/shared/CustomButton.tsx
// components / Shared / CustomButton.tsx

import { colors } from '@/constants/colors';
import React from 'react';
import {
  ActivityIndicator, GestureResponderEvent,
  StyleSheet, Text,
  TouchableOpacity, View
} from 'react-native';


interface CustomButtonProps {
  text: string;
  onPress: ((event: GestureResponderEvent) => void) | undefined;
  loading?: boolean;
  disabled?: boolean;
  style?: Object;
}
const CustomButton = ({ onPress, text, loading, disabled, style }: CustomButtonProps) => {
  return (
    <View style={style}>
      <TouchableOpacity
        onPress={onPress}
        style={styles.btn}
        disabled={loading || disabled}
      >
        {
          loading ?
            <ActivityIndicator size={'small'} color={styles.actvIndicator.color} />
            :
            <Text style={styles.text}>{text}</Text>
        }
      </TouchableOpacity>
    </View>
  );
};


export default CustomButton;

const styles = StyleSheet.create({
  btn: {
    backgroundColor: colors.PRIMARY,
    height: 50,
    borderRadius: 100,
    marginTop: 15,
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontFamily: 'roboto-bold',
    fontSize: 20,
    color: colors.BG_WHITE,
  },
  actvIndicator: {
    color: colors.BG_WHITE,
  }
});
================================================================================

// File: services/location.ts

import * as Location from 'expo-location';
import * as TaskManager from 'expo-task-manager';

const LOCATION_TASK_NAME = 'background-location-task';

export const requestLocationPermissions = async () => {
  const { status: foregroundStatus } = await Location.requestForegroundPermissionsAsync();
  if (foregroundStatus === 'granted') {
    const { status: backgroundStatus } = await Location.requestBackgroundPermissionsAsync();
    if (backgroundStatus === 'granted') {
      return true;
    }
  }
  return false;
};

export const startLocationUpdates = async () => {
  await Location.startLocationUpdatesAsync(LOCATION_TASK_NAME, {
    accuracy: Location.Accuracy.Balanced,
    timeInterval: 1000 * 60 * 5, // 5 minutes
    deferredUpdatesInterval: 1000 * 60 * 1, // 1 minute
    showsBackgroundLocationIndicator: true,
  });
};

export const stopLocationUpdates = async () => {
  await Location.stopLocationUpdatesAsync(LOCATION_TASK_NAME);
};

TaskManager.defineTask(LOCATION_TASK_NAME, ({ data, error }) => {
  if (error) {
    console.error(error);
    return;
  }
  if (data) {
    const { locations } = data as { locations: Location.LocationObject[] };
    console.log('Received new locations', locations);
    // Here you would send the location to your backend API
  }
});

================================================================================

// File: interfaces/interfaces.d.ts
interface Movie {
  id: number;
  title: string;
  adult: boolean;
  backdrop_path: string;
  genre_ids: number[];
  original_language: string;
  original_title: string;
  overview: string;
  popularity: number;
  poster_path: string;
  release_date: string;
  video: boolean;
  vote_average: number;
  vote_count: number;
}

interface TrendingMovie {
  searchTerm: string;
  movie_id: number;
  title: string;
  count: number;
  poster_url: string;
}

interface MovieDetails {
  adult: boolean;
  backdrop_path: string | null;
  belongs_to_collection: {
    id: number;
    name: string;
    poster_path: string;
    backdrop_path: string;
  } | null;
  budget: number;
  genres: {
    id: number;
    name: string;
  }[];
  homepage: string | null;
  id: number;
  imdb_id: string | null;
  original_language: string;
  original_title: string;
  overview: string | null;
  popularity: number;
  poster_path: string | null;
  production_companies: {
    id: number;
    logo_path: string | null;
    name: string;
    origin_country: string;
  }[];
  production_countries: {
    iso_3166_1: string;
    name: string;
  }[];
  release_date: string;
  revenue: number;
  runtime: number | null;
  spoken_languages: {
    english_name: string;
    iso_639_1: string;
    name: string;
  }[];
  status: string;
  tagline: string | null;
  title: string;
  video: boolean;
  vote_average: number;
  vote_count: number;
}

interface TrendingCardProps {
  movie: TrendingMovie;
  index: number;
}

================================================================================

